import{_ as G}from"./iframe-f56ff2b4.js";import"../sb-preview/runtime.js";const V="stencil-components",v={allRenderFn:!0,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!1,cmpDidRender:!1,cmpDidUnload:!1,cmpDidUpdate:!1,cmpShouldUpdate:!1,cmpWillLoad:!1,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!1,constructableCSS:!0,cssAnnotations:!0,devTools:!1,disconnectedCallback:!1,element:!1,event:!1,formAssociated:!1,hasRenderFn:!0,hostListener:!1,hostListenerTarget:!1,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!1,hotModuleReplacement:!1,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!1,hydratedClass:!0,initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!0,isTesting:!0,lazyLoad:!0,lifecycle:!1,lifecycleDOMEvents:!0,member:!0,method:!1,mode:!1,observeAttribute:!0,patchPseudoShadowDom:!1,profile:!1,prop:!0,propBoolean:!0,propMutable:!1,propNumber:!1,propString:!0,reflect:!0,scoped:!1,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!0,slot:!1,slotChildNodesFix:!1,slotRelocation:!1,state:!1,style:!0,svg:!1,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!1,vdomKey:!1,vdomListener:!1,vdomPropOrAttr:!0,vdomRef:!1,vdomRender:!0,vdomStyle:!1,vdomText:!0,vdomXlink:!1,watchCallback:!1};let k,C,ee=!1,N=null,O=!1;const y=(e,t="")=>()=>{},he=(e,t)=>()=>{},ge="{visibility:hidden}.hydrated{visibility:inherit}",q={},ye=e=>e!=null,M=e=>(e=typeof e,e==="object"||e==="function");function te(e){var t,s,n;return(n=(s=(t=e.head)===null||t===void 0?void 0:t.querySelector('meta[name="csp-nonce"]'))===null||s===void 0?void 0:s.getAttribute("content"))!==null&&n!==void 0?n:void 0}const ve=(e,t,...s)=>{let n=null,o=!1,r=!1;const l=[],a=c=>{for(let $=0;$<c.length;$++)n=c[$],Array.isArray(n)?a(n):n!=null&&typeof n!="boolean"&&((o=typeof e!="function"&&!M(n))?n=String(n):typeof e!="function"&&n.$flags$===void 0&&w(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),o&&r?l[l.length-1].$text$+=n:l.push(o?H(null,n):n),r=o)};if(a(s),t){e==="input"&&be(t);{const c=t.className||t.class;c&&(t.class=typeof c!="object"?c:Object.keys(c).filter($=>c[$]).join(" "))}}l.some(_)&&w(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);const i=H(e,null);return i.$attrs$=t,l.length>0&&(i.$children$=l),i},H=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s},Se={},_=e=>e&&e.$tag$===Se,be=e=>{const t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;const n=t.indexOf("type"),o=t.indexOf("min"),r=t.indexOf("max"),l=t.indexOf("step");(s<n||s<o||s<r||s<l)&&P('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},Ee=(e,t)=>e!=null&&!M(e)?t&4?e==="false"?!1:e===""||!!e:t&1?String(e):e:e,ne=(e,t,s)=>{const n=f.ce(t,s);return e.dispatchEvent(n),n},F=new WeakMap,Te=(e,t,s)=>{let n=A.get(e);Fe&&s?(n=n||new CSSStyleSheet,typeof n=="string"?n=t:n.replaceSync(t)):n=t,A.set(e,n)},xe=(e,t,s)=>{var n;const o=se(t),r=A.get(o);if(e=e.nodeType===11?e:m,r)if(typeof r=="string"){e=e.head||e;let l=F.get(e),a;if(l||F.set(e,l=new Set),!l.has(o)){{a=m.createElement("style"),a.innerHTML=r;const i=(n=f.$nonce$)!==null&&n!==void 0?n:te(m);i!=null&&a.setAttribute("nonce",i),e.insertBefore(a,e.querySelector("link"))}l&&l.add(o)}}else e.adoptedStyleSheets.includes(r)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,r]);return o},Le=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=y("attachStyles",t.$tagName$),r=xe(z&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);n&10&&(s["s-sc"]=r,s.classList.add(r+"-h")),o()},se=(e,t)=>"sc-"+e.$tagName$,J=(e,t,s,n,o,r)=>{if(s!==n){let l=We(e,t);if(t.toLowerCase(),t==="class"){const a=e.classList,i=Q(s),c=Q(n);a.remove(...i.filter($=>$&&!c.includes($))),a.add(...c.filter($=>$&&!i.includes($)))}else{const a=M(n);if((l||a&&n!==null)&&!o)try{if(e.tagName.includes("-"))e[t]=n;else{const i=n??"";t==="list"?l=!1:(s==null||e[t]!=i)&&(e[t]=i)}}catch{}n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&e.removeAttribute(t):(!l||r&4||o)&&!a&&(n=n===!0?"":n,e.setAttribute(t,n))}}},ke=/\s/,Q=e=>e?e.split(ke):[],oe=(e,t,s,n)=>{const o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,r=e&&e.$attrs$||q,l=t.$attrs$||q;for(n in r)n in l||J(o,n,r[n],void 0,s,t.$flags$);for(n in l)J(o,n,r[n],l[n],s,t.$flags$)},R=(e,t,s,n)=>{const o=t.$children$[s];let r=0,l,a;if(o.$elm$&&w(`The JSX ${o.$text$!==null?`"${o.$text$}" text`:`"${o.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),o.$text$!==null)l=o.$elm$=m.createTextNode(o.$text$);else if(l=o.$elm$=m.createElement(o.$tag$),oe(null,o,ee),ye(k)&&l["s-si"]!==k&&l.classList.add(l["s-si"]=k),o.$children$)for(r=0;r<o.$children$.length;++r)a=R(e,o,r),a&&l.appendChild(a);return l},le=(e,t,s,n,o,r)=>{let l=e,a;for(l.shadowRoot&&l.tagName===C&&(l=l.shadowRoot);o<=r;++o)n[o]&&(a=R(null,s,o),a&&(n[o].$elm$=a,l.insertBefore(a,t)))},ae=(e,t,s)=>{for(let n=t;n<=s;++n){const o=e[n];if(o){const r=o.$elm$;r&&r.remove()}}},we=(e,t,s,n)=>{let o=0,r=0,l=t.length-1,a=t[0],i=t[l],c=n.length-1,$=n[0],d=n[c],h;for(;o<=l&&r<=c;)a==null?a=t[++o]:i==null?i=t[--l]:$==null?$=n[++r]:d==null?d=n[--c]:L(a,$)?(T(a,$),a=t[++o],$=n[++r]):L(i,d)?(T(i,d),i=t[--l],d=n[--c]):L(a,d)?(T(a,d),e.insertBefore(a.$elm$,i.$elm$.nextSibling),a=t[++o],d=n[--c]):L(i,$)?(T(i,$),e.insertBefore(i.$elm$,a.$elm$),i=t[--l],$=n[++r]):(h=R(t&&t[r],s,r),$=n[++r],h&&a.$elm$.parentNode.insertBefore(h,a.$elm$));o>l?le(e,n[c+1]==null?null:n[c+1].$elm$,s,n,r,c):r>c&&ae(t,o,l)},L=(e,t)=>e.$tag$===t.$tag$,T=(e,t)=>{const s=t.$elm$=e.$elm$,n=e.$children$,o=t.$children$;t.$tag$;const r=t.$text$;r===null?(oe(e,t,ee),n!==null&&o!==null?we(s,n,t,o):o!==null?(e.$text$!==null&&(s.textContent=""),le(s,null,t,o,0,o.length-1)):n!==null&&ae(n,0,n.length-1)):e.$text$!==r&&(s.data=r)},Pe=(e,t,s=!1)=>{const n=e.$hostElement$,o=e.$cmpMeta$,r=e.$vnode$||H(null,null),l=_(t)?t:ve(null,null,t);if(C=n.tagName,Array.isArray(t)&&t.some(_))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${C.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(o.$attrsToReflect$&&(l.$attrs$=l.$attrs$||{},o.$attrsToReflect$.map(([a,i])=>l.$attrs$[i]=n[a])),s&&l.$attrs$)for(const a of Object.keys(l.$attrs$))n.hasAttribute(a)&&!["key","ref","style","class"].includes(a)&&(l.$attrs$[a]=n[a]);l.$tag$=null,l.$flags$|=4,e.$vnode$=l,l.$elm$=r.$elm$=n.shadowRoot||n,k=n["s-sc"],T(r,l)},re=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},B=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return re(e,e.$ancestorComponent$),Qe(()=>Ae(e,t))},Ae=(e,t)=>{const s=e.$hostElement$,n=y("scheduleUpdate",e.$cmpMeta$.$tagName$),o=e.$lazyInstance$;let r;return t?E(s,"componentWillLoad"):E(s,"componentWillUpdate"),E(s,"componentWillRender"),n(),Ie(r,()=>Ce(e,o,t))},Ie=(e,t)=>De(e)?e.then(t):t(),De=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Ce=async(e,t,s)=>{var n;const o=e.$hostElement$,r=y("update",e.$cmpMeta$.$tagName$),l=o["s-rc"];s&&Le(e);const a=y("render",e.$cmpMeta$.$tagName$);e.$flags$|=1024,Oe(e,t,o,s),e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025,l&&(l.map(i=>i()),o["s-rc"]=void 0),a(),r();{const i=(n=o["s-p"])!==null&&n!==void 0?n:[],c=()=>He(e);i.length===0?c():(Promise.all(i).then(c),e.$flags$|=4,i.length=0)}},Oe=(e,t,s,n)=>{try{N=t,t=t.render(),e.$flags$&=-17,e.$flags$|=2,(v.hasRenderFn||v.reflect)&&(v.vdomRender||v.reflect)&&(v.hydrateServerSide||Pe(e,t,n))}catch(i){I(i,e.$hostElement$)}return N=null,null},He=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=y("postUpdate",t);e.$lazyInstance$;const o=e.$ancestorComponent$;E(s,"componentDidRender"),e.$flags$&64?(E(s,"componentDidUpdate"),n()):(e.$flags$|=64,ce(s),E(s,"componentDidLoad"),n(),e.$onReadyResolve$(s),o||ie()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&W(()=>B(e,!1)),e.$flags$&=-517},ie=e=>{ce(m.documentElement),W(()=>ne(D,"appload",{detail:{namespace:V}}))},E=(e,t)=>{ne(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:V}})},ce=e=>e.classList.add("hydrated"),_e=(e,t)=>b(e).$instanceValues$.get(t),je=(e,t,s,n)=>{const o=b(e),r=o.$hostElement$,l=o.$instanceValues$.get(t),a=o.$flags$,i=o.$lazyInstance$;s=Ee(s,n.$members$[t][0]);const c=Number.isNaN(l)&&Number.isNaN(s),$=s!==l&&!c;(!(a&8)||l===void 0)&&$&&(o.$instanceValues$.set(t,s),o.$flags$&1024?P(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,r,`
New value`,s,`
Old value`,l):o.$flags$&2048&&P(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,r,`
New value`,s,`
Old value`,l),i&&(a&18)===2&&B(o,!1))},$e=(e,t,s)=>{var n;if(t.$members$){const o=Object.entries(t.$members$),r=e.prototype;if(o.map(([l,[a]])=>{(a&31||s&2&&a&32)&&Object.defineProperty(r,l,{get(){return _e(this,l)},set(i){{const c=b(this);!(s&1)&&!(c.$flags$&8)&&a&31&&!(a&1024)&&P(`@Prop() "${l}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}je(this,l,i,t)},configurable:!0,enumerable:!0})}),s&1){const l=new Map;r.attributeChangedCallback=function(a,i,c){f.jmp(()=>{const $=l.get(a);if(this.hasOwnProperty($))c=this[$],delete this[$];else{if(r.hasOwnProperty($)&&typeof this[$]=="number"&&this[$]==c)return;if($==null){const d=b(this),h=d==null?void 0:d.$flags$;if(!(h&8)&&h&128&&c!==i){d.$hostElement$;const p=d.$lazyInstance$,g=t.$watchers$[a];g==null||g.forEach(u=>{p[u]!=null&&p[u].call(p,c,i,a)})}return}}this[$]=c===null&&typeof this[$]=="boolean"?!1:c})},e.observedAttributes=Array.from(new Set([...Object.keys((n=t.$watchers$)!==null&&n!==void 0?n:{}),...o.filter(([a,i])=>i[0]&15).map(([a,i])=>{const c=i[1]||a;return l.set(c,a),i[0]&512&&t.$attrsToReflect$.push([a,c]),c})]))}}return e},ze=async(e,t,s,n)=>{let o;if(!(t.$flags$&32)){t.$flags$|=32;{if(o=Ne(s,t),o.then){const i=he(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);o=await o,i()}if(!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);o.isProxied||($e(o,s,2),o.isProxied=!0);const a=y("createInstance",s.$tagName$);t.$flags$|=8;try{new o(t)}catch(i){I(i)}t.$flags$&=-9,a(),j(t.$lazyInstance$)}if(o.style){let a=o.style;const i=se(s,t.$modeName$);if(!A.has(i)){const c=y("registerStyles",s.$tagName$);v.shadowDomShim&&s.$flags$&8&&(a=await G(()=>import("./shadow-css-4f9ce44d-73a7c17a.js"),[],import.meta.url).then($=>$.scopeCss(a,i,!1))),Te(i,a,!!(s.$flags$&1)),c()}}}const r=t.$ancestorComponent$,l=()=>B(t,!0);r&&r["s-rc"]?r["s-rc"].push(l):l()},j=e=>{},Ue=e=>{if(!(f.$flags$&1)){const t=b(e),s=t.$cmpMeta$,n=y("connectedCallback",s.$tagName$);if(t.$flags$&1)de(e,t,s.$listeners$),t!=null&&t.$lazyInstance$?j(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>j(t.$lazyInstance$));else{t.$flags$|=1;{let o=e;for(;o=o.parentNode||o.host;)if(o["s-p"]){re(t,t.$ancestorComponent$=o);break}}s.$members$&&Object.entries(s.$members$).map(([o,[r]])=>{if(r&31&&e.hasOwnProperty(o)){const l=e[o];delete e[o],e[o]=l}}),ze(e,t,s)}n()}},X=e=>{},Me=async e=>{if(!(f.$flags$&1)){const t=b(e);t!=null&&t.$lazyInstance$?X(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>X(t.$lazyInstance$))}},Re=(e,t={})=>{var s;const n=y(),o=[],r=t.exclude||[],l=D.customElements,a=m.head,i=a.querySelector("meta[charset]"),c=m.createElement("style"),$=[];let d,h=!0;Object.assign(f,t),f.$resourcesUrl$=new URL(t.resourcesUrl||"./",m.baseURI).href,e.map(p=>{p[1].map(g=>{const u={$flags$:g[0],$tagName$:g[1],$members$:g[2],$listeners$:g[3]};u.$members$=g[2],u.$attrsToReflect$=[],!z&&u.$flags$&1&&(u.$flags$|=8);const x=u.$tagName$,me=class extends HTMLElement{constructor(S){super(S),S=this,Be(S,u),u.$flags$&1&&(z?S.attachShadow({mode:"open"}):"shadowRoot"in S||(S.shadowRoot=S))}connectedCallback(){d&&(clearTimeout(d),d=null),h?$.push(this):f.jmp(()=>Ue(this))}disconnectedCallback(){f.jmp(()=>Me(this))}componentOnReady(){return b(this).$onReadyPromise$}};u.$lazyBundleId$=p[0],!r.includes(x)&&!l.get(x)&&(o.push(x),l.define(x,$e(me,u,1)))})});{c.innerHTML=o+ge,c.setAttribute("data-styles","");const p=(s=f.$nonce$)!==null&&s!==void 0?s:te(m);p!=null&&c.setAttribute("nonce",p),a.insertBefore(c,i?i.nextSibling:a.firstChild)}h=!1,$.length?$.map(p=>p.connectedCallback()):f.jmp(()=>d=setTimeout(ie,30)),n()},de=(e,t,s,n)=>{},fe=new WeakMap,b=e=>fe.get(e),Be=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$renderCount$=0,s.$onReadyPromise$=new Promise(n=>s.$onReadyResolve$=n),e["s-p"]=[],e["s-rc"]=[],de(e,s,t.$listeners$),fe.set(e,s)},We=(e,t)=>t in e,I=(e,t)=>(0,console.error)(e,t),ue=["STENCIL:"],w=(...e)=>console.error(...ue,...e),P=(...e)=>console.warn(...ue,...e),Y=new Map,Ne=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(typeof o!="string"){w(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}const r=Y.get(o);if(r)return r[n];/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return G(()=>import(`./${o}.entry.js`),[],import.meta.url).then(l=>(Y.set(o,l),l[n]),I)},A=new Map,D=typeof window<"u"?window:{},m=D.document||{head:{}};D.HTMLElement;const f={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},z=v.shadowDomShim&&v.shadowDom?(()=>(m.head.attachShadow+"").indexOf("[native")>-1)():!0,qe=e=>Promise.resolve(e),Fe=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),K=[],pe=[],Je=(e,t)=>s=>{e.push(s),O||(O=!0,t&&f.$flags$&4?W(U):f.raf(U))},Z=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){I(s)}e.length=0},U=()=>{Z(K),Z(pe),(O=K.length>0)&&f.raf(U)},W=e=>qe().then(e),Qe=Je(pe,!0),Xe=(e,t)=>{if(!(typeof window>"u"))return Re([["fab-button",[[1,"fab-button",{label:[1],primary:[516],rounded:[1]}]]]],t)};(function(){if(typeof window<"u"&&window.Reflect!==void 0&&window.customElements!==void 0){var e=HTMLElement;window.HTMLElement=function(){return Reflect.construct(e,[],this.constructor)},HTMLElement.prototype=e.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,e)}})();Xe();const Ze={parameters:{actions:{argTypesRegex:"^on[A-Z].*"},controls:{matchers:{color:/(background|color)$/i,date:/Date$/i}}}};export{Ze as default};
//# sourceMappingURL=preview-6067eb5b.js.map
